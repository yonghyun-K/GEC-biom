#   method = "DS"
# )
# res_est = estimate(y_S ~ 1, calibration = calibration)$estimate
#
# theta_res = c(theta_res, setNames(res_est[1] / N, "IPW"))
# se_res = c(se_res, setNames(res_est[2] / N, "IPW"))
# Hajek estimator
# const = N
# calibration <- GEcalib(
#   ~ 1,
#   dweight = d_S,
#   data = nhis.samp,
#   const = const,
#   entropy = 1,
#   method = "DS"
# )
# res_est = estimate(y_S ~ 1, calibration = calibration)$estimate
#
# theta_res = c(theta_res, setNames(res_est[1] / N, "SIPW"))
# se_res = c(se_res, setNames(res_est[2] / N, "SIPW"))
# SIPW estimator
theta_res = c(theta_res, IPW = sum((y_S) / pihat[index]) / sum(1 / pihat[index])) # AIPW
hhat = pihat * model.matrix(~1, data = nhis)
kappa = solve(t(hhat[index,]) %*% (hhat[index,] * (1 / pihat[index] - 1) / pihat[index]),
t(hhat[index,]) %*% ((y_S - yhat[index]) * (1 / pihat[index] - 1) / pihat[index]))
eta = yhat + drop(hhat %*% kappa)
eta[index] = eta[index] + (y_S - yhat[index] - drop(hhat %*% kappa)[index]) / pihat[index]
se_res = c(se_res, IPW = sqrt(var(eta) / N))
# AIPW estimator
# theta_res = c(theta_res, AIPW = (sum(yhat) + sum((y_S - yhat[index]) / pihat[index])) / N) # AIPW
#
# if(pimethod == 1){
#   hhat = pihat * model.matrix(Rmodel)
# }else if(pimethod == 2){
#   hhat = pihat / (1 - pihat) * model.matrix(Rmodel)
# }
# # hhat = pihat * model.matrix(Rmodel)
# kappa = solve(t(hhat[index,]) %*% (hhat[index,] * (1 / pihat[index] - 1) / pihat[index]),
#               t(hhat[index,]) %*% ((y_S - yhat[index]) * (1 / pihat[index] - 1) / pihat[index]))
# eta = yhat + drop(hhat %*% kappa)
# eta[index] = eta[index] + (y_S - yhat[index] - drop(hhat %*% kappa)[index]) / pihat[index]
#
# se_res = c(se_res, AIPW = sqrt(var(eta) / N))
vectmp <- as.character(formula(Omodel))[3]
# vectmp <- c("Y_IP")
fortmp <- formula(paste("~", paste(vectmp, collapse = "+")))
fortmp2 <- formula(paste("~", paste(c(vectmp, "g(d_S)"), collapse = "+")))
# Omodel_d = lm(reformulate(vectmp, response = "y_S"), weights = 1 / pi_S, data = smho98.samp)
# # Omodel_d = lm(reformulate(paste0("x.", 1:pcol), response = "y"), data = data_S)
#
# yhat_d = predict.lm(Omodel_d, smho98.samp, type = "response")
# e2 = (yhat_d - y_S)^2
# Vmodel_d = glm(reformulate(vectmp, response = "e2"),
#                weights = 1 / pi_S, data = smho98.samp)
# vhat = predict.glm(Vmodel_d, smho98, type = "response")
for (entropy in list(-1, -1/2, 1, "CE")) {
if(entropy == "CE") pihat = ifelse(pihat > 0.6, 0.6, pihat) # To make CE convergent
d_S <- 1 / pihat[index]
# const = colSums(model.matrix(fortmp, nhis))
#
# calibration <- GEcalib(
#   fortmp,
#   dweight = d_S,
#   data = nhis.samp,
#   const = const,
#   entropy = entropy,
#   method = "DS"
# )
#
# res_est = estimate(y_S ~ 1, calibration = calibration)$estimate
#
# theta_res = c(theta_res, setNames(res_est[1] / N, paste("DS", entropy, sep = "_"))) # DS
# se_res = c(se_res, setNames(res_est[2] / N, paste("DS", entropy, sep = "_")))
if(pimethod == 1){
const = colSums(model.matrix(fortmp, nhis))
calibration <- GEcalib(
fortmp,
dweight = d_S,
data = nhis.samp,
const = const,
entropy = entropy,
method = "GEC0"
)
}else{
const = colSums(cbind(model.matrix(fortmp, nhis),
g(1 / pihat, entropy = entropy)))
calibration <- GEcalib(
fortmp2,
dweight = d_S,
data = nhis.samp,
const = const,
entropy = entropy,
method = "GEC"
)
}
calibration
res_est = estimate(y_S ~ 1, calibration = calibration)$estimate
theta_res = c(theta_res, setNames(res_est[1] / N, paste("GEC", entropy, sep = "_"))) # DS
se_res = c(se_res, setNames(res_est[2] / N, paste("GEC", entropy, sep = "_")))
# Double ML method
x_R <- c("AgeGroup", "REGION1", "SEX")
x_Y <- c("AgeGroup", "SEX", "HT", "WT", "Waist", "Alcohol",
"SysBP", "DiaBP", "FBS", "Creatinine")
K       <- 5  # fewer folds = faster
fold_id <- sample(rep(1:K, length.out = N))
folds   <- split(seq_len(N), fold_id)
cf_tbl <- do.call(
rbind,
lapply(folds, function(test) {
train <- setdiff(seq_len(N), test)
## 1) RF for P(delta = 1 | X_R)
train_R <- nhis[train, x_R, drop = FALSE]
train_R$delta <- factor(delta[train], levels = c(0, 1))
rf_R <- ranger(
delta ~ .,
data        = train_R,
probability = TRUE,
num.trees   = 200,      # lower than 500
importance  = "none",
keep.inbag  = FALSE
)
test_R  <- nhis[test, x_R, drop = FALSE]
prob_RF <- predict(rf_R, data = test_R)$predictions
p_hat   <- prob_RF[, "1"]
## 2) RF for E[Hemo | X_Y] using only observed Y
obs_train <- train[delta[train] == 1]
train_Y   <- nhis[obs_train, c("Hemo", x_Y)]
rf_Y <- ranger(
Hemo ~ .,
data      = train_Y,
num.trees = 200,
importance = "none",
keep.inbag = FALSE
)
y_hat <- predict(rf_Y, data = nhis[test, x_Y, drop = FALSE])$predictions
data.frame(i = test, pihat_DML = p_hat, yhat_DML = y_hat)
})
)
pihat_DML <- numeric(N); pihat_DML[cf_tbl$i] <- cf_tbl$pihat_DML
yhat_DML  <- numeric(N); yhat_DML[cf_tbl$i]  <- cf_tbl$yhat_DML
if(pimethod == 0){
pihat_DML = pi
}else if(pimethod == 1){
pihat_DML = rep(n / N, N)
}
AIPW_mean_Hemo_RF <- mean(yhat_DML) + sum((y_S - yhat_DML[index]) / pihat_DML[index]) / sum(1 / pihat_DML[index])
AIPW_mean_Hemo_RF
## --- AIPW / DML estimator of the population mean ---
eta <- yhat_DML + delta * (nhis$Hemo - yhat_DML) / pihat_DML
theta_res = c(theta_res, DML = AIPW_mean_Hemo_RF) # AIPW
se_res = c(se_res, DML = sqrt(var(eta) / sum(1 / pihat_DML[index])))
}
}
CR_res = ifelse(abs(theta_res - theta) < qnorm(0.975) * se_res, 1, 0)
list(theta_res, se_res, CR_res)
}
# Model-assisted calibration using
# Generalized entropy calibration in survey sampling
# Simulation setup
if (!interactive()) {
args <- as.numeric(commandArgs(trailingOnly = TRUE))
} else{
args <- c(5)
}
timenow1 = Sys.time()
timenow0 = gsub(' ', '_', gsub('[-:]', '', timenow1))
timenow = paste(timenow0, ".txt", sep = "")
# install.packages( "MatrixModels", type="win.binary" )
library(nleqslv)
library(PracTools)
suppressMessages(library(foreach))
suppressMessages(library(doRNG))
# library(caret)
library(tidyverse)
library(xtable)
library(GECal)
# library(mice)
# library(kableExtra)
library(ranger)
load("../data/nhis.Rdata")
set.seed(11)
SIMNUM = args[1]
if (!interactive()) {
suppressMessages(library(doMC))
dir.create(timenow0)
setwd(timenow0)
sink(timenow, append = TRUE)
## doMC backend registration
nc <- parallel::detectCores(logical = TRUE)
reserve <- 2L
target <- max(1L, nc - reserve)
want_workers <- 500L
workers <- max(1L, min(want_workers, SIMNUM))
Sys.setenv(OMP_NUM_THREADS="1", MKL_NUM_THREADS="1", OPENBLAS_NUM_THREADS="1")
registerDoMC(workers)
message(sprintf("doMC backend: detectCores=%d, using workers=%d", nc, getDoParWorkers()))
# (Optional) Somke test
.ok <- tryCatch({
aa <- foreach(i = 1:getDoParWorkers(), .combine=c) %dopar% i
length(aa) == getDoParWorkers()
}, error=function(e){ message("Smoke test failed: ", conditionMessage(e)); FALSE })
if (!.ok) stop("doMC Smoke test failed")
}else{
suppressMessages(library(doParallel))
# ## setup parallel backend to use many processors
print(paste("detectCores =", detectCores()))
cores = min(detectCores() - 3, 120)
# cores = 2
print(paste("cores =", cores))
# cl <- makeCluster(cores, outfile = timenow) #not to overload your computer
cl <- makeCluster(cores)
registerDoParallel(cl)
}
N <- nrow(nhis)
tab1 = table(nhis$AgeGroup, nhis$REGION1, nhis$SEX)
nh_min = 5
tab1 = ifelse(tab1 > 3 * nh_min, nh_min, round(tab1 / 3))
# tab1 = ifelse(tab1 > 3 * nh_min, nh_min, tab1)
n = sum(tab1)
nhis$Smoking <- ifelse(nhis$Smoking == 3, 1, 0)
# summary(nhis)
print("y is Hemo")
# nhis$Hemo <- nhis$OralExam; print("y is OralExam")  # Variable of interest y is Smoking
theta = mean(nhis$Hemo)
print(paste("theta =", theta))
final_res <- foreach(
simnum = 1:SIMNUM,
.packages = c("nleqslv", "PracTools", "GECal", "ranger"),
.errorhandling = "pass"
) %dorng% {
index = c()
pi_S = c()
pi = rep(0, N)
for(AgeGroup in unique(nhis$AgeGroup)){
for(REGION1 in unique(nhis$REGION1)){
for(SEX in unique(nhis$SEX)){
idx_tmp = which(nhis$AgeGroup == AgeGroup &
nhis$REGION1 == REGION1 &
nhis$SEX == SEX)
n_h = tab1[AgeGroup,REGION1,SEX]
index = c(index, sample(idx_tmp, n_h, replace = FALSE))
pi_S = c(pi_S, rep(n_h / length(idx_tmp), n_h))
pi[idx_tmp] = n_h / length(idx_tmp)
}
}
}
# summary(pi)
delta = as.integer(1:N %in% index)
Rmodel = glm(delta ~ AgeGroup + REGION1 + SEX, family = binomial,
data = nhis)
# Rmodel = glm(delta ~ AgeGroup * REGION1 * SEX, family = binomial,
#              data = nhis)
# Rmodel = glm(delta ~ AgeGroup + REGION1 + SEX + HT + WT + Waist + Alcohol + SysBP + DiaBP+ FBS + Creatinine, family = binomial,
#              data = nhis)
# Rmodel = glm(delta ~ AgeGroup + SEX, family = binomial,
#              data = nhis)
pihat0 = predict.glm(Rmodel, nhis, type = "response")
findphi2 = function(phi, x0, Z, delta, ..., returnw = F){
pi_phi = drop(1 / (1 + exp(-x0 %*% phi)))
w_phi = ifelse(delta, (1 - pi_phi) / pi_phi, -1)
if(returnw){
return(drop(1 / pi_phi))
}else{
return(drop(w_phi %*% Z))
}
}
jacphi2 = function(phi, x0, Z, delta, ..., returnw = F){
pi_phi = drop(1 / (1 + exp(-x0 %*% phi)))
logit_phi = pi_phi / (1 - pi_phi)
return(-t(Z) %*% (x0 * ifelse(delta, 1 / logit_phi, 0) ))
# return(-t(x0) %*% (Z * ifelse(delta, 1 / logit_phi, logit_phi) ))
}
xR = model.matrix(Rmodel)
nleqslv_res = nleqslv(Rmodel$coefficients, findphi2, jac = jacphi2, x0 = xR, Z = xR, delta = delta,
control = list(maxit = 1e5, allowSingular = T), xscalm = "auto",
method = "Newton")
if(nleqslv_res$termcd != 1 & max(abs(findphi2(nleqslv_res$x, x0 = xR, Z = xR, delta = delta))) > 1e-5){
w_S = NA
}else{
w_S = findphi2(nleqslv_res$x, x0 = xR, Z = xR, delta = delta, returnw = T)
}
# drop(t(xR[Index_S,]) %*% w_S2[Index_S]); colSums(xR)
w_S2 = w_S
# summary(lm(Smoking ~ ., data = nhis))
# Omodel = lm(Hemo ~ AgeGroup + SEX + HT + WT, data = nhis)
Omodel = lm(Hemo ~ AgeGroup + SEX + HT + WT + Waist + Alcohol + SysBP + DiaBP + FBS + Creatinine, data = nhis)
yhat = predict.lm(Omodel, nhis, type = "response")
nhis.samp <- nhis[index, ]
# d_S       <- 1 / pi_S
y_S <- nhis.samp$Hemo
# omega2_S = matrix(0, nrow = length(index), ncol = length(index))
# for (cnt in 1:5) {
#   idx_strat2 = which(smho98.samp$stratum5 == cnt)
#   # omega2_S[idx_strat2, idx_strat2] <-
#   diag(omega2_S)[idx_strat2] <-
#     1 / pi_S[idx_strat2] * (1 / pi_S[idx_strat2] - 1)
# }
theta_res = NULL
se_res = NULL
for(pimethod in c(0,1,3)){
if(pimethod == 0){
pihat = pi
}else if(pimethod == 1){
pihat = rep(n / N, N)
}else if(pimethod == 2){
pihat = pihat0
}else if(pimethod == 3){
pihat = 1 / w_S2
}
d_S <- 1 / pihat[index]
# #HT estimator
# const = numeric(0)
# calibration <- GEcalib(
#   ~ 0,
#   dweight = d_S,
#   data = nhis.samp,
#   const = const,
#   entropy = 1,
#   method = "DS"
# )
# res_est = estimate(y_S ~ 1, calibration = calibration)$estimate
#
# theta_res = c(theta_res, setNames(res_est[1] / N, "IPW"))
# se_res = c(se_res, setNames(res_est[2] / N, "IPW"))
# Hajek estimator
# const = N
# calibration <- GEcalib(
#   ~ 1,
#   dweight = d_S,
#   data = nhis.samp,
#   const = const,
#   entropy = 1,
#   method = "DS"
# )
# res_est = estimate(y_S ~ 1, calibration = calibration)$estimate
#
# theta_res = c(theta_res, setNames(res_est[1] / N, "SIPW"))
# se_res = c(se_res, setNames(res_est[2] / N, "SIPW"))
# SIPW estimator
theta_res = c(theta_res, IPW = sum((y_S) / pihat[index]) / sum(1 / pihat[index])) # AIPW
hhat = pihat * model.matrix(~1, data = nhis)
kappa = solve(t(hhat[index,]) %*% (hhat[index,] * (1 / pihat[index] - 1) / pihat[index]),
t(hhat[index,]) %*% ((y_S - yhat[index]) * (1 / pihat[index] - 1) / pihat[index]))
eta = yhat + drop(hhat %*% kappa)
eta[index] = eta[index] + (y_S - yhat[index] - drop(hhat %*% kappa)[index]) / pihat[index]
se_res = c(se_res, IPW = sqrt(var(eta) / N))
# AIPW estimator
# theta_res = c(theta_res, AIPW = (sum(yhat) + sum((y_S - yhat[index]) / pihat[index])) / N) # AIPW
#
# if(pimethod == 1){
#   hhat = pihat * model.matrix(Rmodel)
# }else if(pimethod == 2){
#   hhat = pihat / (1 - pihat) * model.matrix(Rmodel)
# }
# # hhat = pihat * model.matrix(Rmodel)
# kappa = solve(t(hhat[index,]) %*% (hhat[index,] * (1 / pihat[index] - 1) / pihat[index]),
#               t(hhat[index,]) %*% ((y_S - yhat[index]) * (1 / pihat[index] - 1) / pihat[index]))
# eta = yhat + drop(hhat %*% kappa)
# eta[index] = eta[index] + (y_S - yhat[index] - drop(hhat %*% kappa)[index]) / pihat[index]
#
# se_res = c(se_res, AIPW = sqrt(var(eta) / N))
x_R <- c("AgeGroup", "REGION1", "SEX")
x_Y <- c("AgeGroup", "SEX", "HT", "WT", "Waist", "Alcohol",
"SysBP", "DiaBP", "FBS", "Creatinine")
K       <- 5  # fewer folds = faster
fold_id <- sample(rep(1:K, length.out = N))
folds   <- split(seq_len(N), fold_id)
cf_tbl <- do.call(
rbind,
lapply(folds, function(test) {
train <- setdiff(seq_len(N), test)
## 1) RF for P(delta = 1 | X_R)
train_R <- nhis[train, x_R, drop = FALSE]
train_R$delta <- factor(delta[train], levels = c(0, 1))
rf_R <- ranger(
delta ~ .,
data        = train_R,
probability = TRUE,
num.trees   = 200,      # lower than 500
importance  = "none",
keep.inbag  = FALSE
)
test_R  <- nhis[test, x_R, drop = FALSE]
prob_RF <- predict(rf_R, data = test_R)$predictions
p_hat   <- prob_RF[, "1"]
## 2) RF for E[Hemo | X_Y] using only observed Y
obs_train <- train[delta[train] == 1]
train_Y   <- nhis[obs_train, c("Hemo", x_Y)]
rf_Y <- ranger(
Hemo ~ .,
data      = train_Y,
num.trees = 200,
importance = "none",
keep.inbag = FALSE
)
y_hat <- predict(rf_Y, data = nhis[test, x_Y, drop = FALSE])$predictions
data.frame(i = test, pihat_DML = p_hat, yhat_DML = y_hat)
})
)
pihat_DML <- numeric(N); pihat_DML[cf_tbl$i] <- cf_tbl$pihat_DML
yhat_DML  <- numeric(N); yhat_DML[cf_tbl$i]  <- cf_tbl$yhat_DML
if(pimethod == 0){
pihat_DML = pi
}else if(pimethod == 1){
pihat_DML = rep(n / N, N)
}
AIPW_mean_Hemo_RF <- mean(yhat_DML) + sum((y_S - yhat_DML[index]) / pihat_DML[index]) / sum(1 / pihat_DML[index])
AIPW_mean_Hemo_RF
## --- AIPW / DML estimator of the population mean ---
eta <- yhat_DML + delta * (nhis$Hemo - yhat_DML) / pihat_DML
AIPW_var_Hemo_RF = sqrt(var(eta) / sum(1 / pihat_DML[index]))
vectmp <- as.character(formula(Omodel))[3]
# vectmp <- c("Y_IP")
fortmp <- formula(paste("~", paste(vectmp, collapse = "+")))
fortmp2 <- formula(paste("~", paste(c(vectmp, "g(d_S)"), collapse = "+")))
# Omodel_d = lm(reformulate(vectmp, response = "y_S"), weights = 1 / pi_S, data = smho98.samp)
# # Omodel_d = lm(reformulate(paste0("x.", 1:pcol), response = "y"), data = data_S)
#
# yhat_d = predict.lm(Omodel_d, smho98.samp, type = "response")
# e2 = (yhat_d - y_S)^2
# Vmodel_d = glm(reformulate(vectmp, response = "e2"),
#                weights = 1 / pi_S, data = smho98.samp)
# vhat = predict.glm(Vmodel_d, smho98, type = "response")
for (entropy in list(-1, -1/2, 1, "CE")) {
if(entropy == "CE") pihat = ifelse(pihat > 0.6, 0.6, pihat) # To make CE convergent
d_S <- 1 / pihat[index]
# const = colSums(model.matrix(fortmp, nhis))
#
# calibration <- GEcalib(
#   fortmp,
#   dweight = d_S,
#   data = nhis.samp,
#   const = const,
#   entropy = entropy,
#   method = "DS"
# )
#
# res_est = estimate(y_S ~ 1, calibration = calibration)$estimate
#
# theta_res = c(theta_res, setNames(res_est[1] / N, paste("DS", entropy, sep = "_"))) # DS
# se_res = c(se_res, setNames(res_est[2] / N, paste("DS", entropy, sep = "_")))
if(pimethod == 1){
const = colSums(model.matrix(fortmp, nhis))
calibration <- GEcalib(
fortmp,
dweight = d_S,
data = nhis.samp,
const = const,
entropy = entropy,
method = "GEC0"
)
}else{
const = colSums(cbind(model.matrix(fortmp, nhis),
g(1 / pihat, entropy = entropy)))
calibration <- GEcalib(
fortmp2,
dweight = d_S,
data = nhis.samp,
const = const,
entropy = entropy,
method = "GEC"
)
}
calibration
res_est = estimate(y_S ~ 1, calibration = calibration)$estimate
theta_res = c(theta_res, setNames(res_est[1] / N, paste("GEC", entropy, sep = "_"))) # DS
se_res = c(se_res, setNames(res_est[2] / N, paste("GEC", entropy, sep = "_")))
theta_res = c(theta_res, DML = AIPW_mean_Hemo_RF) # AIPW
se_res = c(se_res, DML = AIPW_var_Hemo_RF)
}
}
CR_res = ifelse(abs(theta_res - theta) < qnorm(0.975) * se_res, 1, 0)
list(theta_res, se_res, CR_res)
}
paste("# of failure:", sum(!sapply(lapply(final_res, function(x) x[[1]]), function(x) is.numeric(unlist(x)))));
final_res0 = lapply(final_res, function(x) x[[1]])
print(final_res0[!sapply(final_res0, function(x) is.numeric(unlist(x)))])
final_res = final_res[sapply(final_res, length) == max(sapply(final_res, length))]
if(!interactive()) save.image(paste(timenow0, ".RData", sep = ""))
final_res1 = lapply(final_res, function(x) x[[1]])
# stopCluster(cl)
timenow2 = Sys.time()
print(timenow2 - timenow1)
# if(sum(!sapply(final_res1, function(x) is.numeric(unlist(x)))) != 0) stop(paste(final_res1))
final_res1 = final_res1[sapply(final_res1, function(x) is.numeric(unlist(x)))]
# res1 <- Reduce(`+`, final_res1) / length(final_res1)
# colnames(res1) = rnames
tmpres = do.call(rbind, lapply(final_res1, c))
BIAS = colMeans(tmpres - theta, na.rm = TRUE)
SE = sqrt(colMeans(apply(tmpres, 2, function(x) (x - mean(x, na.rm = TRUE))^2), na.rm = TRUE))
RMSE = sqrt(colMeans((tmpres - theta)^2, na.rm = TRUE))
res <- cbind(BIAS, SE, RMSE)
rownames(res) = names(final_res1[[1]])
res
xtable(res * 1e2, digits = 2)
colSums(is.na(tmpres))
final_res2 = lapply(final_res, function(x) x[[2]])
final_res2 = final_res2[sapply(final_res2, function(x) is.numeric(unlist(x)))]
tmpres2 = do.call(rbind, lapply(final_res2, c))
final_res3 = lapply(final_res, function(x) x[[3]])
final_res3 = final_res3[sapply(final_res3, function(x) is.numeric(unlist(x)))]
tmpres3 = do.call(rbind, lapply(final_res3, c))
res2 = cbind(RB = (colMeans(tmpres2^2, na.rm = TRUE) - SE^2) / SE^2,
CR = colMeans(tmpres3, na.rm = TRUE) * 1e2)
xtable(res2)
# hist(g(1 / pi, entropy = -1))
# hist(g(1 / pi, entropy = 0))
# hist(1 / pi)
# summary(1 / pi)
# summary(lm(EXPTOTAL ~ . + I(1/pi), data = smho98))
# summary(lm(smho98$EXPTOTAL ~ I(1/pi)))
# summary(lm(EXPTOTAL ~ I(1/pi) + Y_IP, data = smho98))
